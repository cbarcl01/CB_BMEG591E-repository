---
title: "Assignment 3: Mappability"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
---


The data is located under the */usr/local/share/data/assignment_3/* path (unless otherwise specified). 

The deliverable for this assignment will be both the Rmd file (this one, with your answers added). And the same being `knit` into an html. You will submit both Rmd and html. 


## 0. Getting ready 0.5pt

### a. Activate conda environment

```{bash, eval=FALSE}
conda activate Gnme_Assignment_1
```

Note: I didn't realise we would use the same environment the whole time when we set up the conda environment in assignment 1, hence the name 'Gnme_Assignment_1' :)


### b. Install trimmomatic

```{bash, eval=FALSE}
 conda install -c bioconda trimmomatic
```


## 1. Sequencing parameters

There are two main things that you want further clarification on before telling your Professor how do you want to do the next sequence run: appropriate sequence length and run type (paired-end or single-end). You have reviewed some of these concepts in class and you have a vague notion of what you should use, but after the traumatic event of losing all your data, you won't take any chances and decide to make sure that what you learned in class is right.


### a. Sequence length

You have decided that you want to see the percentage of uniquely mapped reads when you use different read lengths. 

Use **ONLY** the **H3K27me3_iPSC_SRA60_subset_1.fastq.gz** file from your last assignment located in **/usr/local/share/data/assignment_2/ ** in the course server. 

#### i) Use trimmomatic SE to crop the file to 25 bp in length 1 pt

```{bash, eval=FALSE}
trimmomatic SE -threads 4 /usr/local/share/data/assignment_2/H3K27me3_iPSC_SRA60_subset_1.fastq.gz ./H3K27me3_iPSC_SRA60_subset_1.trimmed.fastq.gz CROP:25
```



#### ii) Map 25 bp read file to reference genome 0.5 pt

```{bash, eval=FALSE}
bowtie2 -x /usr/local/share/indexes/hg38_bowtie2_index \ -U ./H3K27me3_iPSC_SRA60_subset_1.trimmed.fastq.gz \ -S ./H3K27me3_iPSC_SRA60_subset_1.aligned.sam
```



#### iii) Number of uniquely mapped reads 0.5 pt

```{bash, eval=FALSE}
sambamba view -h -F "[XS] == null and not unmapped and not duplicate"  ./H3K27me3_iPSC_SRA60_subset_1.aligned.sam -o unique_mapped.bam
```


**Output**

1891826 reads; of these:
  1891826 (100.00%) were unpaired; of these:
    7842 (0.41%) aligned 0 times
    1325510 (70.07%) aligned exactly 1 time
    558474 (29.52%) aligned >1 times
99.59% overall alignment rate



#### iv) Create a pipeline 5 pts

**Pipeline (3pts)** 
You realize that if you want to consider many different read lengths, copying and pasting the above for each read length will be very repetitive work and prone to bugs. Thus, you decide to use your recently acquired knowledge of pipelines to create a mini version of it that will take as input the desired read length, and output the number of uniquely mapped reads when reads of this length have been mapped to the genome. 

```{bash, eval=FALSE}
#!/bin/bash
set -e 
sample=$1
filename=$2
last=LEN_25
echo running pipeline for $sample
if [ $sample == "$last" ];
then
      sambamba view -h -F "[XS] == null and not unmapped and not duplicate" ./$filename -o ./uniquelyMappedReads.bam
else        
      sambamba view -h -F "[XS] == null and not unmapped and not duplicate" /usr/local/share/data/assignment_3/$filename -o ./uniquelyMappedReads.bam
fi
```


**Job scheduler (1.5pt)**

```{bash, eval=FALSE}
./runTheseJobsSerially.sh ./sambambaPipeline.sh ./taskfile.tsv
```


**Taskfile (0.5pt)**

```{bash, eval=FALSE}
LEN_150 H3K27me3_iPSC_SRA60_subset_1_LEN_150_mapped.bam
LEN_100 H3K27me3_iPSC_SRA60_subset_1_LEN_100_mapped.bam
LEN_75 H3K27me3_iPSC_SRA60_subset_1_LEN_75_mapped.bam
LEN_50 H3K27me3_iPSC_SRA60_subset_1_LEN_50_mapped.bam
LEN_25 H3K27me3_iPSC_SRA60_subset_1.aligned.sam
```

**Output**
running pipeline for LEN_150
1572284
running pipeline for LEN_100
1505177
running pipeline for LEN_75
1459621
running pipeline for LEN_50
1401739
running pipeline for LEN_25
1325969
(Gnme_Assignment_1) [cbarcl01@SBME-GI-EDU-SV4 ~]$



Now that you have the number of uniquely mapped reads for the different reads size, you want to make a nice graph to show your supervisor you know what you are talking about when you say the sequence length has an effect on the number of uniquely mapped reads. **On your local computer**:


#### v) Create a dataframe 1pt

```{r, eval=FALSE}
library(tidyverse)
length_mapped_reads.df <- data.frame(reads_length=c(150,100,75,50,25),
                       uniquely_mapped_reads=c(1572284,1505177,1459621,1401739,1325969))
```


```{r}
library(tidyverse)
length_mapped_reads.df <- data.frame(reads_length=c(150,100,75,50,25),
                       uniquely_mapped_reads=c(1572284,1505177,1459621,1401739,1325969))
```


#### vi) Create a scatterplot 2pt

```{r, eval=FALSE}
ggplot(data = length_mapped_reads.df) + 
  geom_point(mapping = aes(x = reads_length, y = uniquely_mapped_reads))
```

```{r}
ggplot(data = length_mapped_reads.df) + 
  geom_point(mapping = aes(x = reads_length, y = uniquely_mapped_reads))
```



### b. Paired-end vs Single-end reads


Now that you have proven that the longest read length yields the highest number of uniquely mapped reads, you decide to test the difference between a paired-end run versus a single-end run. 

```{bash, eval=FALSE}
## Using the following files: 
# /usr/local/share/data/assignment_3/H3K27me3_iPSC_SRA60_subset_1_LEN_25.fastq.gz
# /usr/local/share/data/assignment_3/H3K27me3_iPSC_SRA60_subset_2_LEN_25.fastq.gz
## And the index of the hg38 genome build: 
## /usr/local/share/indexes/hg38_bowtie2_index
#?# Perform a paired-end (PE) analysis, type the command you used below: - 0.5 pt


#?# Do a single-end (SE) analysis of the subset_1 file , type the command you used below: - 0.5 pt


#?# Convert the PE sam file to bam format, type the command you used below: - 0.5 pt


#?# Convert the SE sam file to bam format, type the command you used below: - 0.5 pt


## Before moving on: remove the PE and SE sam alignment files!
#?# Use sambamba view to get the number of uniquely mapped reads for the PE alignment, type the command you used below: - 0.5 pt 


#?# Use sambamba view to get the number of uniquely mapped reads for the SE alignment, type the command you used below: - 0.5 pt 


```

Your supervisor liked so much the graphical representation of your data, that he asks you to do a barplot for the SE versus PE alignment comparison.**On your local computer:**

```{r, eval=FALSE}
## First, we create a dataframe with two columns, one (run_type) for the different run types and another (uniquely_mapped_reads for the number of uniquely mapped reads.
#?# Substitute the SE and PE with their respective number of uniquely mapped reads that you got from sambamba view: - 1 pt
sequence_run.df <- data.frame(run_type=c("Single End", "Paired End"),
                              uniquely_mapped_reads=c(SE,PE))
                              
                              
#?# Using ggplot, create a barplot that shows the different number of uniquely mapped reads between the two run types: - 2 pt
## Use the run_type in the x-axis
## Use the uniquely_mapped_reads in the y-axis


#?# Does the run type makes a difference? If there is, is it large? - 1 pt


#?# In your own words explain the difference between SE and PE read alignment. - 1 pt


#?# Given that the 50 bp reads (from last graph) contain the same number of bases as two 25 bp reads (25 bp PE; 25+25=50), why are the number of uniquely mapping reads different between these two? Which has more? Why do you think this is? - 3 pts
  
```

Knit this document and upload it and your Rmd file to your private GitHub repo. Submit URLs to both for the assignment submission.

Correctly knitting your assignment to html - 2 pts
